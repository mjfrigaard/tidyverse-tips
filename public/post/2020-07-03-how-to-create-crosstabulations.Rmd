---
title: How to create crosstabulations with janitor, dplyr, and tidyr
author: Martin Frigaard
date: '2020-07-03'
slug: how-to-create-crosstabulations
categories:
  - count
tags:
  - rstats
---


```{r setup, include=FALSE}
library(tidyverse)
library(hrbrthemes)
library(tidytidbits)
knitr::opts_chunk$set(echo = TRUE, # show/hide all code
                      # results = 'hide', # hide results
                      tidy = FALSE, # cleaner code printing
                      comment = "#> ", # better console printing
                      eval = TRUE, # turn this to FALSE stop code chunks from running
                      message = FALSE, # show messages
                      warning = FALSE, # show warnings
                      size = "small", # size of the text
                      # fig.keep = FALSE, # keep figures?
                      fig.width = 9, # size of the fig
                      fig.height = 7, # size of the fig
                      collapse = TRUE,
                      eval = TRUE, 
                      warning = FALSE,
                      message = FALSE)
options(dplyr.tibble.print = 10)
# set theme
ggplot2::theme_set(hrbrthemes::theme_ipsum_tw(
  base_size = 10,
  strip_text_size = 11,
  axis_title_size = 13,
  plot_title_size = 17,
  subtitle_size = 13,
  base_family = "Ubuntu",
  strip_text_family = "TitilliumWeb-Regular",
  axis_title_family = "TitilliumWeb-Regular",
  subtitle_family = "TitilliumWeb-Regular",
  plot_title_family = "JosefinSans-Regular"
))
```

### General cross-tabulations?

This post was inspired by two 2015 [tweets](https://twitter.com/JennyBryan/status/599379158452416512) from [Jenny Bryan](https://twitter.com/JennyBryan). 

Here is the first tweet, 

![](/post/2020-07-03-how-to-create-crosstabulations_files/jbtwee1.png){width=80%}

The original question had some follow-up clarification from Jenny Bryan, which is presented below:

![](/post/2020-07-03-how-to-create-crosstabulations_files/jbtwee2.png){width=80%}

Cross-tabulations (or [contingency tables](https://en.wikipedia.org/wiki/Contingency_table)) are very helpful for counting things, especially if you're dealing with categorical variables that have multiple responses.

The original tweets resulted in quite a few responses from the #rstats community for creating "general cross-tabulation[s]," all of which are summarized in this [gist](https://gist.github.com/jennybc/04b71bfaaf0f88d9d2eb#file-2015-05-15_cross-tabulation-md). 

However, some great new packages have come out in the last five years! This post is an attempt to update and add to the gist with more options for creating crosstabs.

### What goes in a crosstabulations?

Crosstabulations (or crosstabs) are summary tables displaying counts of categorical variables. Categorical variables typically have a defined set of known values, and the simplest of these being binary (`yes`/`no`, `true`/`false`, etc.). 

Therefore, the cross-tabulation of two binary variables is sometimes referred to as a *2 X 2 contingency table*. 

### The 2 x 2 table

We'll start by looking at the vaccination for Polio created by Jonas Salk.

```{r PolioVac2x2, echo=FALSE}
PolioVac2x2 <- tibble::tribble(
                   ~`-`, ~Polio, ~`No Polio`,  ~Total,
         "Salk Vaccine",    57L,     200688L, 200745L,
      "Placebo Vaccine",   142L,     201087L, 201229L,
                "Total",   199L,     401775L, 401974L)
```

```{r , eval=FALSE}
PolioVac2x2
```

```{r paged_table-PolioVac2x2, echo=FALSE}
rmarkdown::paged_table(PolioVac2x2)
```


These data come from the [1955 paper by Francis et al](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1622939/pdf/amjphnation00353-0017.pdf). You might be wondering why we'd create a table like this? Well, displaying cross-tabulations allows us to see the results summarized by the experimental conditions. 

![](/post/2020-07-03-how-to-create-crosstabulations_files/tidy-crosstabs.png){width=80%}

In this table, 

1. Two cells support the argument of an effective vaccine (the children getting the `Salk Vaccine` didn't develop polio (`No Polio`), and the children who received the `Placebo Vaccine` developed `Polio`), 

1. Two cells support the argument of an ineffective vaccine (children getting the `Placebo Vaccine` didn't develop polio (`No Polio`), and the children who received the `Salk Vaccine` developed `Polio`), 

Cross-tabulations are also used to calculate a lot of dichotomous tests, too (like [sensitivity, specificity](https://en.wikipedia.org/wiki/Sensitivity_and_specificity), [likelihood ratios](https://en.wikipedia.org/wiki/Likelihood_ratios_in_diagnostic_testing), etc).

### The `gss_cat` data 

The `gss_cat` data come from the [`forcats` package](https://forcats.tidyverse.org/), and it has *sample of categorical variables from the General Social survey*. 

We'll use the `inspectdf::inspect_cat()` plot to take a look at the levels in each factor variable.

```{r gss_cat}
library(inspectdf)
gss_cat <- forcats::gss_cat
gss_cat %>% 
  inspectdf::inspect_cat() %>% 
  inspectdf::show_plot(text_labels = TRUE)
```

This graph shows us the `gss_cat` dataset has six factor variables on mostly irreligious (`Not applicable`), `Married`, `Independent`, `White`, `Protestant` people making `$25,000` or more. 

### Create a binary `married` variable

Someone told me to always name binary variables the name of the response it represents, that way I would never wonder what the `1`s and `0`s mean. For example, a variable named `married` would be `1` = "married" and `0` = "not married". 

Coding responses this way is also handy if you're summing binary categories. Below we will create a numeric binary variable called `married`, which will be coded as, 

`"Married"` = `1`  

`"Never married"`/`"Separated"`/`"Divorced"`/`"Widowed"` = `0`

`"No answer"` = `NA`

We'll use `dplyr::mutate()` and `dplyr::case_when()`:

```{r married}
gss_cat <- gss_cat %>% 
  dplyr::mutate(married = case_when(
    
    marital == "Married" ~ 1, 
    
    marital == "Never married" ~ 0, 
    marital == "Separated" ~ 0, 
    marital == "Divorced" ~ 0, 
    marital == "Widowed" ~ 0, 
    
    marital == "No answer" ~ NA_real_,
    TRUE ~ NA_real_))
```

### Crosstabs with `dplyr` and `tidyr`

How would we know if we create the `marital` variable right? 

Well, we could create a cross-tab of `marital` and `married` using `dplyr::group_by()` and `dplyr::summarize()`.

```{r group-by, eval=FALSE}
gss_cat %>%
  dplyr::group_by(marital, married) %>%
  dplyr::summarize(married = sum(married == 1),
                  `not married` = sum(married == 0))
```

```{r group-by-paged_table, echo=FALSE}
rmarkdown::paged_table(
gss_cat %>%
  dplyr::group_by(marital, married) %>%
  dplyr::summarize(married = sum(married == 1),
                  `not married` = sum(married == 0))
)
```

How can we check our work? Well, before we do that, we will cover the differences between `dplyr::group_by()` + `dplyr::summarize()`, `dplyr::count()`, and the lower level function `dplyr::tally()`.

#### `group_by`, `summarize` & `count`

`dplyr::count()` is really the `dplyr::group_by()` and `dplyr::summarize()` functions combined. Per the description from the help file,

*equivalent to `df %>% group_by(a, b) %>% summarise(n = n())`*

So, the call above used `dplyr::group_by()` and `dplyr::summarize()` to collapse the original `gss_cat` tibble into the available categories in `marital` and `married`. 

We then we fed the output of `dplyr::group_by(marital, married)` + `dplyr::summarize()` to the `sum()` function, but we had to specify the two conditions (`married == 1` and `not married == 0`) in order to get a 2 x 2 table. 

If we compare `dplyr::group_by()` + `dplyr::summarize(n = n())` with the numbers from `dplyr::count()` below, we see they are identical.

```{r count-by-summarize-marital-married, eval=FALSE}
gss_cat %>%
  dplyr::count(marital, married)
```

```{r count-paged_table-marital-married, echo=FALSE}
rmarkdown::paged_table(
gss_cat %>%
  dplyr::count(marital, married)
)
```

```{r group-by-summarize-marital-married, eval=FALSE}
gss_cat %>% 
  dplyr::group_by(marital, married) %>% 
  dplyr::summarise(n = n())
```

```{r group-by-summarize-marital-married-paged_table, echo=FALSE}
rmarkdown::paged_table(
gss_cat %>% 
  dplyr::group_by(marital, married) %>% 
  dplyr::summarise(n = n())
)
```

All the categories from `marital` and `married` are accounted for. 

#### `tally`

The `dplyr::tally()` function doesn't do any grouping before it counts up the categorical levels, so if we try to use it like `dplyr::count()`, we get an error.

```{r , error=TRUE}
gss_cat %>% 
  dplyr::tally(marital, married)
```

If we can use `dplyr::group_by(marital, married)` and then feed it to `dplyr::tally()`, it works fine. 

```{r tally-marital-married, eval=FALSE}
gss_cat %>% 
  dplyr::group_by(marital, married) %>% 
  dplyr::tally()
```

```{r tally-marital-married-paged_table, echo=FALSE}
rmarkdown::paged_table(
gss_cat %>% 
  dplyr::group_by(marital, married) %>% 
  dplyr::tally())
```

But none of these functions give us an output that distributes the categorical responses across the columns (unless we provide all levels of one of the grouped variables). 

Which, as Jenny points out, would be a *horrifying* idea if we had a categorical variable that had multiple levels. Consider `rincome` (16 levels) and `denom` (30 levels)!

A crosstabulation gives us an idea of where the counts overlap for each response category, but so far we've only been able to see all possible combinations of `marital` and `married` with a single `n` column.

#### `count` & `pivot`

We can combine `dplyr` with `tidyr` to create quick cross-tabs for categorical variables. First we'll use `dplyr::count()` to get the counts for each response, then we can change the structure of the output from the collapsed tibble with `tidyr::pivot_wider()`. 

For example, we can count `married` and `marital`, then pivot `married` responses across the columns. 

```{r count-marital-married-pivot_wider-race, eval=FALSE}
gss_cat %>%
  dplyr::count(married, marital) %>% 
  tidyr::pivot_wider(names_from = married, 
                     values_from = n)
```

```{r count-marital-married-pivot_wider-race-paged_table, echo=FALSE}
rmarkdown::paged_table(
gss_cat %>%
  dplyr::count(married, marital) %>% 
  tidyr::pivot_wider(names_from = married, 
                     values_from = n)
)
```

Or we can pivot the `marital` categories across the columns.

```{r count-marital-married-pivot_wider-marital, eval=FALSE}
gss_cat %>%
  dplyr::count(married, marital) %>% 
  tidyr::pivot_wider(names_from = marital, 
                     values_from = n)
```

```{r count-marital-married-pivot_wider-marital-paged_table, echo=FALSE}
rmarkdown::paged_table(
gss_cat %>%
  dplyr::count(married, marital) %>% 
  tidyr::pivot_wider(names_from = marital, 
                     values_from = n)
)
```

In both cases, we can see the each categorical level of `married` and `marital` printed to the screen, with the `n` for each cell.

### Previous examples

**Note** 1) `tidyr::spread()` is roughly equivalent to `tidyr::pivot_wider()`, so these are updated versions of the previous answers below, 2) recall that `mtcars` is a `data.frame`, not a `tibble`, so the printing will look different.

```{r previous-group-by-summarize, eval=FALSE}
base::class(mtcars)
# [1] "data.frame"

# group_by, summarize, and spread ---- ---- ----
mtcars %>%
  dplyr::group_by(cyl, vs) %>%
  dplyr::summarize(count = n()) %>%
  tidyr::spread(vs, count)
# `summarise()` regrouping output by 'cyl' (override with `.groups` argument)
# # A tibble: 3 x 3
# # Groups:   cyl [3]
#     cyl   `0`   `1`
#   <dbl> <int> <int>
# 1     4     1    10
# 2     6     3     4
# 3     8    14    NA
```

As you can see from the output above, when `dplyr::group_by()` and `dplyr::summarize()` are combined, a message tells us it would be `regrouping` the output `tibble` (we can fix this with `dplyr::ungroup()` or `.groups`). 

```{r previous-group-by-tally-spread, eval=FALSE}
# group_by, tally, and spread ---- ---- ----
mtcars %>%
  dplyr::group_by(cyl, vs) %>%
  dplyr::tally() %>%
  tidyr::spread(vs, n)
# # A tibble: 3 x 3
# # Groups:   cyl [3]
#     cyl   `0`   `1`
#   <dbl> <int> <int>
# 1     4     1    10
# 2     6     3     4
# 3     8    14    NA
```

In the second example, `dplyr::group_by(cyl, vs)` was combined with `dplyr::tally()`, and they return a grouped `tibble` *without* a message or warning (because it assumes we want the `tibble` to remain grouped).

```{r previous-count-tally-spread, eval=FALSE}
# count and spread ---- ---- ----
mtcars %>%
  dplyr::count(cyl, vs) %>%
  tidyr::spread(vs, n) 
#   cyl  0  1
# 1   4  1 10
# 2   6  3  4
# 3   8 14 NA
```

The final example uses only `dplyr::count()` and `tidyr::spread()` and returns a regular `data.frame`. 


### Cross`tabyls` with `janitor`

The [`janitor` package](https://garthtarr.github.io/meatR/janitor.html) has a ton of great tools for data wrangling (see `janitor::clean_names()`), and this package also creates crosstabs with it's `tabyl()` function.

We'll create a `tabyl` of marital and race called `MarRacTabyl` below:

```{r MarRacTabyl, eval=TRUE}
library(janitor)
MarRacTabyl <- gss_cat %>% 
  janitor::tabyl(marital, race)
class(MarRacTabyl)
```

`tabyl`s are their own class, which allows for beautifully formatted crosstabs that print nicely to the console or Rmarkdown file. 

```{r print-MarRacTabyl}
MarRacTabyl
```


The output of a `tabyl` is nearly identical to the output from `dplyr::count()` + `tidyr::pivot_wider()`, but `janitor` makes it easy to add totals, percentages, and formatting using the `adorn_()` functions:
 
#### Add a total column 


```{r tabyl-adorn-totals, eval=FALSE}
# add total column ----  ----  ----  ---- 
MarRacTabyl %>% 
  janitor::adorn_totals(where = "col")

       marital Other Black White Not applicable Total
     No answer     2     2    13              0    17
 Never married   633  1305  3478              0  5416
     Separated   110   196   437              0   743
      Divorced   212   495  2676              0  3383
       Widowed    70   262  1475              0  1807
       Married   932   869  8316              0 10117
```

#### Add a total row

```{r MarRacTabyl-show_missing_levels, echo=FALSE}
MarRacTabyl <- gss_cat %>% 
  janitor::tabyl(marital, race, 
                 show_missing_levels = FALSE)
```


```{r tabyl-adorn-totals-row, eval=FALSE}
# add total row, drop missing ----  ----  ----  ---- 
MarRacTabyl <- gss_cat %>% 
  janitor::tabyl(marital, race, 
                 show_missing_levels = FALSE)
MarRacTabyl %>% 
  janitor::adorn_totals(where = "row")

       marital Other Black White
     No answer     2     2    13
 Never married   633  1305  3478
     Separated   110   196   437
      Divorced   212   495  2676
       Widowed    70   262  1475
       Married   932   869  8316
         Total  1959  3129 16395
```

#### Add percentages (and round) 

```{r tabyl-adorn-percent-row-digits, eval=FALSE}
# add percentages and format ----  ----  ----  ---- 
MarRacTabyl %>% 
  janitor::adorn_percentages("row") %>%
  janitor::adorn_pct_formatting(digits = 2) 

       marital  Other  Black  White
     No answer 11.76% 11.76% 76.47%
 Never married 11.69% 24.10% 64.22%
     Separated 14.80% 26.38% 58.82%
      Divorced  6.27% 14.63% 79.10%
       Widowed  3.87% 14.50% 81.63%
       Married  9.21%  8.59% 82.20%
```

#### Add ns and percentages 

```{r tabyl-adorn-percent-row-digits-ns, eval=FALSE}
# add ns with percentages ----  ----  ----  ----
MarRacTabyl %>%
  janitor::adorn_percentages("row") %>%
  janitor::adorn_pct_formatting(digits = 2) %>%
  janitor::adorn_ns()
  
       marital        Other         Black         White
     No answer 11.76%   (2) 11.76%    (2) 76.47%   (13)
 Never married 11.69% (633) 24.10% (1305) 64.22% (3478)
     Separated 14.80% (110) 26.38%  (196) 58.82%  (437)
      Divorced  6.27% (212) 14.63%  (495) 79.10% (2676)
       Widowed  3.87%  (70) 14.50%  (262) 81.63% (1475)
       Married  9.21% (932)  8.59%  (869) 82.20% (8316)
```

It's important to note that the order of the adorn functions matters. For example, calling `janitor::adorn_totals(where = "col")` at the end of this pipeline will throw an error, 

```{r tabyl-adorn-error, eval=FALSE}
MarRacTabyl %>% 
  janitor::adorn_percentages("row") %>%
  janitor::adorn_pct_formatting(digits = 2) %>%
  janitor::adorn_ns() %>% 
  janitor::adorn_totals(where = "col") 
#> Error in janitor::adorn_totals(., where = "col") : 
#>  at least one targeted column must be of class numeric.  Control target 
#>  variables with the ... argument. adorn_totals should be called before 
#>  other adorn_ functions.
```

But, if we add a total column *before* the percentages, everything works fine.

```{r tabyl-adorn-col-total-before-pecentages-ns, eval=FALSE}
MarRacTabyl %>% 
  janitor::adorn_totals(where = "col") %>% 
  janitor::adorn_percentages("row") %>%
  janitor::adorn_pct_formatting(digits = 2) %>%
  janitor::adorn_ns() 

       marital        Other         Black         White Not applicable           Total
     No answer 11.76%   (2) 11.76%    (2) 76.47%   (13)      0.00% (0) 100.00%    (17)
 Never married 11.69% (633) 24.10% (1305) 64.22% (3478)      0.00% (0) 100.00%  (5416)
     Separated 14.80% (110) 26.38%  (196) 58.82%  (437)      0.00% (0) 100.00%   (743)
      Divorced  6.27% (212) 14.63%  (495) 79.10% (2676)      0.00% (0) 100.00%  (3383)
       Widowed  3.87%  (70) 14.50%  (262) 81.63% (1475)      0.00% (0) 100.00%  (1807)
       Married  9.21% (932)  8.59%  (869) 82.20% (8316)      0.00% (0) 100.00% (10117)
```

These also print well with `rmarkdown::paged_table()` and `knitr::kable()`

#### `tabyl` + `paged_table()`

```{r paged_table-MarRacTabyl}
rmarkdown::paged_table(
  MarRacTabyl %>% 
  janitor::adorn_totals(where = "col") %>% 
  janitor::adorn_percentages("row") %>%
  janitor::adorn_pct_formatting(digits = 2) %>%
  janitor::adorn_ns()
)
```

#### `tabyl` + `kable()`

```{r kable-MarRacTabyl}
knitr::kable(
  MarRacTabyl %>% 
  janitor::adorn_totals(where = "col") %>% 
  janitor::adorn_percentages("row") %>%
  janitor::adorn_pct_formatting(digits = 2) %>%
  janitor::adorn_ns()
)
```

***

### Crosstabs with `tidytidbits`

The last example I will mention is from the [`tidytidbits`](https://cran.r-project.org/web/packages/tidytidbits/tidytidbits.pdf) package. The `cross_tabulate()` produces a nicely printed `table` output.

```{r tidytidbits-MarRacCross_Tab}
library(tidytidbits)
MarRacCross_Tab <- gss_cat %>% 
  tidytidbits::cross_tabulate(marital, race)
MarRacCross_Tab
```

```{r utils-MarRacCross_Tab}
utils::str(MarRacCross_Tab)
```

But we lose a lot of functionality going from a `data.frame` or `tibble` to a `table`.

The other options from the gist are provided below for posterity:

```{r , eval=FALSE}
#  use melt and dcast on named columns (no pipe)  ---- ---- ---- ----
library(reshape2)     ## dcast(), melt()
library(data.table)
# not this puts a 0, not an NA
reshape2::dcast(reshape2::melt(mtcars[, c("cyl", "vs")], id = "cyl"), cyl ~ value)
  #   cyl  0  1
  # 1   4  1 10
  # 2   6  3  4
  # 3   8 14  0

# combine dplyr and reshape2 with pipes  ---- ---- ---- ----
# @daroczig 
mtcars %>%
  dplyr::group_by(cyl, vs) %>%
  dplyr::summarize(n()) %>%
  reshape2::dcast(cyl ~ vs)
  # `summarise()` regrouping output by 'cyl' (override with `.groups` argument)
  # Using n() as value column: use value.var to override.
  #   cyl  0  1
  # 1   4  1 10
  # 2   6  3  4
  # 3   8 14 NA

# obligatory data.table option 1 (no pipe)  ---- ---- ---- ----
# @daroczig 
mtcarsDT <- mtcars %>% data.table()
dcast(mtcarsDT[, .N, by = list(cyl, vs)], cyl ~ vs)
  # Using 'N' as value column. Use 'value.var' to override
  #    cyl  0  1
  # 1:   4  1 10
  # 2:   6  3  4
  # 3:   8 14 NA

# obligatory data.table option 2 (pipe)  ---- ---- ---- ----
# @MattDowle
mtcarsDT[, .N, .(cyl, vs)] %>% dcast(cyl ~ vs)
# Using 'N' as value column. Use 'value.var' to override
  #    cyl  0  1
  # 1:   4  1 10
  # 2:   6  3  4
  # 3:   8 14 NA
```


## Other resources for crosstabs

Check out these other sources for crosstabs:

1. [Contingency Tables - Analytics with R](http://analyticswithr.com/contingencytables.html)

2. [SO: Cross tables of one variable with all other variables in data.frame](https://stackoverflow.com/questions/54377189/tidyverse-cross-tables-of-one-variable-with-all-other-variables-in-data-frame)

3. [Tabyl vignette](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html).

4. [Pivoting](https://tidyr.tidyverse.org/articles/pivot.html)

5. [Group by](https://dplyr.tidyverse.org/reference/group_by.html) and [summarise](https://dplyr.tidyverse.org/reference/summarise.html) from `dplyr`