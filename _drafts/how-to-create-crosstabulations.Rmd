---
title: How to create crosstabulations
author: Martin Frigaard
date: '2020-06-28'
slug: counting-things
categories: ["Wrangling"]
tags: ["Wrangling"]
---

```{r setup, include=FALSE}
library(tidyverse)
# fig folder
fs::dir_create("figs/")
knitr::opts_chunk$set(echo = FALSE, # show/hide all code
                      # results = 'hide', # hide results
                      tidy = FALSE, # cleaner code printing
                      comment = "#> ", # better console printing
                      eval = TRUE, # turn this to FALSE stop code chunks from running
                      message = FALSE, # show messages
                      warning = FALSE, # show warnings
                      size = "small", # size of the text
                      # fig.keep = FALSE, # keep figures?
                      fig.width = 9, # size of the fig
                      fig.height = 7, # size of the fig
                      fig.path = "figs/", # location of files
                      collapse = TRUE,
                      eval = TRUE, 
                      warning = FALSE,
                      message = FALSE)
options(dplyr.tibble.print = 10)
library(hrbrthemes)
ggplot2::theme_set(hrbrthemes::theme_ipsum_tw(
  base_size = 10,
  strip_text_size = 11,
  axis_title_size = 13,
  plot_title_size = 17,
  subtitle_size = 13,
  base_family = "Ubuntu",
  strip_text_family = "TitilliumWeb-Regular",
  axis_title_family = "TitilliumWeb-Regular",
  subtitle_family = "TitilliumWeb-Regular",
  plot_title_family = "JosefinSans-Regular"
))
```


This post comes from an old [tweet](https://twitter.com/JennyBryan/status/599379158452416512) and [gist](https://gist.github.com/jennybc/04b71bfaaf0f88d9d2eb) from [Jenny Bryan](https://twitter.com/JennyBryan). Cross-tabulations (or simply crosstabs) are very helpful for counting things, especially if you're dealing with data that have multiple categories.

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Help me use dplyr to do this less awkwardly? <a href="https://twitter.com/hashtag/rstats?src=hash&amp;ref_src=twsrc%5Etfw">#rstats</a><br>mtcars %&gt;%<br>group_by(cyl) %&gt;%<br>summarize(vs0 = sum(vs == 0), vs1 = sum(vs == 1))</p>&mdash; Jenny Bryan (@JennyBryan) <a href="https://twitter.com/JennyBryan/status/599379158452416512?ref_src=twsrc%5Etfw">May 16, 2015</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

## The original question

Well, the original question actually had some follow-up clarification from Jenny Bryan, which is below:

<blockquote class="twitter-tweet"><p lang="en" dir="ltr"><a href="https://twitter.com/noamross?ref_src=twsrc%5Etfw">@noamross</a> <a href="https://twitter.com/kwbroman?ref_src=twsrc%5Etfw">@kwbroman</a> no I mean, imagine vs had 7 levels instead of 2 … how to do for a general factor … general cross-tabulation</p>&mdash; Jenny Bryan (@JennyBryan) <a href="https://twitter.com/JennyBryan/status/599380584201265152?ref_src=twsrc%5Etfw">May 16, 2015</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

This resulted in quite a few responses for how to create "general cross-tabulation[s]," all of which are summarized in this [gist](https://gist.github.com/jennybc/04b71bfaaf0f88d9d2eb#file-2015-05-15_cross-tabulation-md). 

However, this gist was created over five years ago, and the #rstats community has had some great new packages come out since the original tweet. This post is an update the list of options for creating crosstabs.

## What is a cross-tab?

Cross-tabulations (also called contingency tables) are summary tables displaying counts of categorical variables. Categorical variables typically have a defined set of known values, and the simplest of these being binary (`yes`/`no`, `true`/`false`, etc.). 

Therefore, the cross-tabulation of two binary variables is sometimes referred to as a *2 X 2 contingency table*. 

### A 2 x 2 Crosstab

We'll start by looking at the vaccination for Polio created by Jonas Salk.

```{r PolioVac2x2}
PolioVac2x2 <- tibble::tribble(
                   ~`-`, ~Polio, ~`No Polio`,  ~Total,
         "Salk Vaccine",    57L,     200688L, 200745L,
      "Placebo Vaccine",   142L,     201087L, 201229L,
                "Total",   199L,     401775L, 401974L)
```

```{r , echo=TRUE, eval=FALSE}
PolioVac2x2
```

```{r paged_table-PolioVac2x2}
rmarkdown::paged_table(PolioVac2x2)
```


These data come from the [1955 paper by Francis et al](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1622939/pdf/amjphnation00353-0017.pdf). You might be wondering why we'd create a table like this? Well, displaying cross-tabulations allows us to see the results summarized by the experimental conditions. In this table, 

1. Two cells support the argument of an effective vaccine (the children getting the `Salk Vaccine` didn't develop polio (`No Polio`), and the children who received the `Placebo Vaccine` were developed `Polio`), 

1. two cells support the argument of an ineffective vaccine (children getting the `Placebo Vaccine` didn't develop polio (`No Polio`), and the children who received the `Salk Vaccine` developed `Polio`), 

```{r tidy-crosstabs}
# fs::dir_ls("figs")
knitr::include_graphics(path = "figs/tidy-crosstabs.png")
```

Cross-tabulations are also used to calculate a lot of dichotomous tests, too. Like [sensitivity, specificity](https://en.wikipedia.org/wiki/Sensitivity_and_specificity), [likelihood ratios](https://en.wikipedia.org/wiki/Likelihood_ratios_in_diagnostic_testing), etc.

### The `gss_cat` data 

The `gss_cat` data come from the [`forcats` package](https://forcats.tidyverse.org/), and it has *sample of categorical variables from the General Social survey*. We'll use the `inspectdf::inspect_cat()` plot to take a look at the levels in each factor variable.

```{r gss_cat}
gss_cat <- forcats::gss_cat
gss_cat %>% 
  inspectdf::inspect_cat() %>% 
  inspectdf::show_plot(text_labels = TRUE)
```


### Binary `black` variable

Someone told me to always name the binary variable the name of the value it represents, this way you're never wondering what the `1`s and `0`s mean. 

For example, a variable named `black` would be `1` = "black" and `0` = "not black". 

This is also handy if you're summing binary categories. Below we will create a numeric binary variable called `black`, which will be coded as, 

`"Black"` = `1`  

`"White"` & `"Other"` = `0`  

`"Not applicable"` & All else will = `NA`

We'll use `dplyr::mutate()` and `dplyr::case_when()`:

```{r black}
gss_cat <- gss_cat %>% 
  dplyr::mutate(black = case_when(
    race == "Black" ~ 1, 
    race == "White" ~ 0, 
    race == "Other" ~ 0, 
    TRUE ~ NA_real_))
```

## Crosstabs with `dplyr` and `tidyr`

How would we know if we create the `black` variable right? 

Well, we could create a cross-tab of `black` and `race` using `dplyr::group_by()` and `dplyr::summarize()`.

```{r group-by, eval=FALSE}
gss_cat %>%
  dplyr::group_by(race, black) %>%
  dplyr::summarize(`not black` = sum(black == 0), 
                   black = sum(black == 1))
```

```{r group-by-paged_table}
rmarkdown::paged_table(
  gss_cat %>%
  dplyr::group_by(race, black) %>%
  dplyr::summarize(`not black` = sum(black == 0), 
                   black = sum(black == 1))
)
```

How can we check our work? Well, before we do that, we will cover the differences between `dplyr::group_by()` + `dplyr::summarize()`, `dplyr::count()`, and the lower level function `dplyr::tally()`.

### `group_by`, `summarize` & `count`

`dplyr::count()` is really the `dplyr::group_by()` and `dplyr::summarize()` functions combined. 

Check the description from the help file,

*equivalent to `df %>% group_by(a, b) %>% summarise(n = n())`*

So the call above used `dplyr::group_by()` and `dplyr::summarize()` to collapse the original `gss_cat` tibble into the available categories in `race` and `black`. We then we fed the output of `dplyr::group_by(race, black)` + `dplyr::summarize()` to the `sum()` function, but we had to specify the two conditions (`black == 0` and `black == 1`) in order to get a 2 x 2 table. 

We'll compare `dplyr::group_by()` + `dplyr::summarize(n = n())` with the numbers from `dplyr::count()` below:

```{r count-group-by-summarize-race-black, eval=FALSE}
gss_cat %>%
  dplyr::count(race, black)
gss_cat %>% 
  dplyr::group_by(race, black) %>% 
  dplyr::summarise(n = n())
```

```{r count-paged_table-race-black}
rmarkdown::paged_table(
gss_cat %>%
  dplyr::count(race, black)
)
```

```{r group-by-summarize-race-black-paged_table, eval=FALSE}
rmarkdown::paged_table(
gss_cat %>% 
  dplyr::group_by(race, black) %>% 
  dplyr::summarise(n = n())
)
```

Identical--all the categories from `black` and `race` are accounted for. 

### `tally`

The `dplyr::tally()` function doesn't do any grouping before it counts up the categorical levels, so if we try to use it like `dplyr::count()`, we get an error.

```{r , error=TRUE}
gss_cat %>% 
  dplyr::tally(race, black)
```

If we can use `dplyr::group_by(race, black)` and then feed it to `dplyr::tally()`, it works fine. 

```{r tally-race-black, eval=FALSE}
gss_cat %>% 
  dplyr::group_by(race, black) %>% 
  dplyr::tally()
```

```{r tally-race-paged_table, echo=FALSE}
rmarkdown::paged_table(
gss_cat %>% 
  dplyr::group_by(race, black) %>% 
  dplyr::tally())
```

But none of these give us the output of a second variable across the columns (unless we provide all levels of one of the grouped variables). 

And as Jenny points out, this process would be *terrible* if we had a categorical variable that had multiple levels. Consider `marital` (6 levels) and `race` (4 levels).

```{r count-marital-race, eval=FALSE}
gss_cat %>% 
  dplyr::count(marital, race)
```

```{r count-marital-race-paged_table}
rmarkdown::paged_table(
gss_cat %>%
  dplyr::count(marital, race)
)
```

This is showing all possible combinations of `marital` and `race` with a single `n` column, and it ends up being 18 rows. 

We really want to know how the counts overlap for each category, and while `dplyr` is great for summarizing these counts, we can combine it with `tidyr` to create quick cross-tabs for categorical variables. 

## `count` & `pivot`
 
In order to create a cross-tabs, we'll have to change the structure of the output from the collapsed tibble (whether from `dplyr::count()` or `dplyr::group_by()` `>%>` `dplyr::summarize(n=n())`). 

We can use `tidyr::pivot_wider()` to shift one of the categorical variables to the columns, and we know the counts are going to be in the `n` column.

```{r count-marital-race-pivot_wider-race, eval=FALSE}
gss_cat %>%
  dplyr::count(marital, race) %>% 
  tidyr::pivot_wider(names_from = race, 
                     values_from = n)
```

```{r count-marital-race-pivot_wider-race-paged_table, echo=FALSE}
rmarkdown::paged_table(
gss_cat %>%
  dplyr::count(marital, race) %>% 
  tidyr::pivot_wider(names_from = race, 
                     values_from = n)
)
```

Or we can pivot the marital categories across the columns.

```{r count-marital-race-pivot_wider-marital, eval=FALSE}
gss_cat %>%
  dplyr::count(marital, race) %>% 
  tidyr::pivot_wider(names_from = marital, 
                     values_from = n)
```

```{r count-marital-race-pivot_wider-marital-paged_table, echo=FALSE}
rmarkdown::paged_table(
gss_cat %>%
  dplyr::count(marital, race) %>% 
  tidyr::pivot_wider(names_from = marital, 
                     values_from = n)
)
```

In both cases, we can see the each categorical level of `race` and `marital`. 

Note that this is the current version of the previous answers (`tidyr::spread()` is roughly equivalent to `tidyr::pivot_wider()`)

Recall that `mtcars` is a `data.frame`, not a `tibble`.

```{r previous-group-by-summarize-tally-count-spread, eval=FALSE}
base::class(mtcars)
# [1] "data.frame"


# group_by, summarize, and spread ---- ---- ----
mtcars %>%
  dplyr::group_by(cyl, vs) %>%
  dplyr::summarize(count = n()) %>%
  tidyr::spread(vs, count)
# `summarise()` regrouping output by 'cyl' (override with `.groups` argument)
# # A tibble: 3 x 3
# # Groups:   cyl [3]
#     cyl   `0`   `1`
#   <dbl> <int> <int>
# 1     4     1    10
# 2     6     3     4
# 3     8    14    NA


# group_by, tally, and spread ---- ---- ----
mtcars %>%
  dplyr::group_by(cyl, vs) %>%
  dplyr::tally() %>%
  tidyr::spread(vs, n)
# # A tibble: 3 x 3
# # Groups:   cyl [3]
#     cyl   `0`   `1`
#   <dbl> <int> <int>
# 1     4     1    10
# 2     6     3     4
# 3     8    14    NA


# count and spread ---- ---- ----
mtcars %>%
  dplyr::count(cyl, vs) %>%
  tidyr::spread(vs, n) %>% str()
#   cyl  0  1
# 1   4  1 10
# 2   6  3  4
# 3   8 14 NA
```

As you can see from the output above, when we combine `dplyr::group_by()` and `dplyr::summarize()`, a message told us it would be `regrouping` the output `tibble` because we didn't use `dplyr::ungroup()` or `.groups`. 

In the second example, `dplyr::group_by(cyl, vs)` was combined with `dplyr::tally()`, and they returned a grouped `tibble` without a message or warning (because it assumes we want the `tibble` to remain grouped).

The final example uses only `dplyr::count()` and `tidyr::spread()` and returns a regular `data.frame`. 


## Cross`tabyls` with `janitor`

The [`janitor` package](https://garthtarr.github.io/meatR/janitor.html) has a ton of great tools for data wrangling (see `janitor::clean_names()`), but it also creates some great crosstabulations too!

The `janitor::tabyl()` function produces beautifully formatted crosstabs

```{r tabyl, eval=FALSE}
gss_cat %>% 
  janitor::tabyl(marital, race)
```

These print a little differently than 

```{r tabyl, echo=FALSE}
rmarkdown::paged_table(
gss_cat %>% 
  janitor::tabyl(marital, race))
```



## Crosstabs with `tidytidbits`

## Other crosstabs



http://analyticswithr.com/contingencytables.html

https://garthtarr.github.io/meatR/lectures/tidyverse.html#1

https://stackoverflow.com/questions/54377189/tidyverse-cross-tables-of-one-variable-with-all-other-variables-in-data-frame 

https://rstudio-pubs-static.s3.amazonaws.com/6975_c4943349b6174f448104a5513fed59a9.html

https://cran.r-project.org/web/packages/gmodels/gmodels.pdf